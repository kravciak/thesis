\chapter{Návrh a Implementácia}
\label{chap:implementacia}

Táto kapitola popisuje implementačné detaily projektu. Kompletný projekt obsahuje štyri časti, serverovú api, jej administračné rozhranie a dva príklady použitia. Administračné rozhranie ako aj oba príklady použitia sú závislé na serverovej časti, na ktorej restové rozhranie sa pripájajú. Serverová api je nezávislá, jedinou prerekvizitou je databáza cassandra, ktorá musí byť spustená ako prvá. Závislosti komponentov aplikácie zobrazuje diagram \ref{image_components}.
\myFigure{components}{Diagram komponentov aplikácie}{Diagram komponentov aplikácie}

Jednotlivé komponenty nájdeme vo výslednom projekte v samostatných adresároch. Projekt navyše obsahuje adresár so vzorovými schémami a udalosťami.

\section{ThesisApi}
	Esper je voľne dostupný pre dve vývojové platformy - javu a .net. Pre serverovú časť aplikácie som zvolil javu s použitím spring frameworku.

	Vo finálnej verzii som ponechal aj súbory v balíčku sample, ktoré slúžia na testovanie aplikácie. Ich použitím je možné jednorázovo spustiť serverovú časť aplikácie, načítať schémy a definovanými pravidlami vyhodnotiť udalosti uložené v csv súboroch v resources adresári. Takéto jednorázové spustenie uľahčuje hľadanie chýb, prípadne testovanie novej funkcionality aplikácie.

	
model
exportall - getall

	\subsection{Konfiguračné súbory}
		Aplikácie využíva konfiguračné súbory umiestnené v adresári resources, ktoré sú načítané pri spustení. Najdôležitejšími z nich sú konfigurácie spring frameworku a databázy:
		\begin{description}
			\item[application-config.xml:] Konfiguračný súbor spring frameworku, ktorého najzaujímavejšou časťou je konfigurácia jdbc. Tá špecifikuje adaptér pripojenia k databáze konfigurácie, konkrétne parametre pripojenia sú načítané zo súboru database.properties.
			\item[database.properties:] Súbor obsahuje nastavenie pripojenia k databázi. Jeho úpravou môžeme jednoducho nahradiť použitý databázový systém iným.
		\end{description}
		Ďalej v tomto adresári nájdeme vzorové schémy udalostí a samotné udalosti použité pre testovanie alebo konfiguráciu logovania.
	
	\subsection{Databáza}
		Aplikácia využíva dve databázy, jednu na ukladanie konfiguračných dát a druhú na udalosti nájdené esperom. Je to tak kvôli predpokladu že esper bude produkovať veľké množstvo dát, preto je vhodné použitie databázy optimalizovanej pre zápis.
		
		Prístup k databázam zabezpečujú triedy v balíčku DAO, ktoré sú pre použitie injektované do ostatných objektov aplikácie. Balíček obsahuje tri triedy, dva z nich slúžia na správu schém a statementov a využívajú konfiguráciu načítanú zo súboru database.properties. Tretia trieda slúži na prácu s výsledkami statementov o jej konfiguráciu sa stará trieda Constants.java. Implementácia triedy obsluhujúcej výsledky je riešená trochu odlišne, kde sú všetky dotazy špecifikované na začiatku a v konštruktore inicializované do objektu PreparedStatement. Je to takto z dôvodu optimalizácie rýchlosti zápisu.			
	
		\subsubsection{Databáza konfigurácie}
		Ako databázu pre ukladanie stavu esperu a jednotlivých konfiguračných položiek som použil \ac{HSQLDB}. Táto databáza je napísaná v jave a pre ukladanie tabuliek ponúka pamäťový aj diskový mód. Použil som ju, pretože je jednoduchá, nenáročná na systém a je možné ju stiahnuť ako jednu zo závislostí aplikácie pomocou mavenu. Databáza je jednoducho nahraditeľná iným riešením, keďže k nej je pristupované pomocou jdbc. Pre zmenu je potrebné upraviť konfiguračný súbor application-config.xml a zmeniť položku dataSource.
		
		Databáza obsahuje tabuľku schém a statementov, ktoré sú načítavané pri štarte Api. Jej štruktúru vidíme na obrázku \ref{image_db-model-1}.
		\myFigure{db-model-1}{Model databázy konfigurácie}{Model databázy konfigurácie}
		
		Pri ukončení aplikácie je nutné sa od databázy odpojiť aby boli zmeny dočasne uložené v pamäti presunuté na disk. Toto odpojenie zaobstaráva spúšťací súbor aplikácie, volaním príkazu "SHUTDOWN". Odpojenie je nutné vykonať aj pri nastavení automatického ukončenia relácie v parametroch pripojenia k databáze.
			
		\subsubsection{Databáza udalostí}
		Databáza udalostí slúži na ukladanie výsledkov vyhovujúcich niektorému z definovaných statementov. Ako konkrétne riešenie som použil databázu Cassandra. Cassandra je jedným z predstaviteľov NoSQL databáz. Jednou z jej výhod je možnosť rozšíriteľnosti v prípade veľkého objemu dát a optimalizácia pre zápis. Použitie tejto databázy je v rámci "proof of concept" princípu, kde by bolo jednoduchšie pracovať napríklad s HSQLDB ako v prípade konfigurácie, avšak kvôli možnosti generovania veľkého množstva udalostí esperom je použitá databáza na to vhodná.
		\myFigure{db-model-2}{Model databázy udalostí}{Model databázy udalostí}
	
	\subsection{Spring framework}
		Ako základ serverovej časti aplikácie som použil Spring framework. Jeho hlavnou úlohou je injektovanie závislostí vo väčšine tried, no využil som aj rozšírenia pre databázu, webový prístup a pribalený webový server tomcat.
		Spring Framework poskytuje v aplikácii podporu pre dependency injection, správu transakcií a prístup k dátam pomocou jdbc. Serverová časť aplikácie využíva nasledujúce knižnice:
		\begin{description}
			\item[spring-core:] Pomocou anotácie @Autowired sú v aplikácii riešené závislosti väčšiny komponent.
			\item[spring-jdbc:] Prístup do databázy je realizovaný pomocou spring triedy NamedParameterJdbcTemplate, ktorá oproti jdbc pridáva možnosť prístupu k vygenerovanému id nového záznamu.
			\item[spring-webmvc:] Prístup k dátam a ovládaniu serverovej časti aplikácie je umožnený pomocou restovej api.
			\item[spring-boot-starter-web:] Táto závislosť umožňuje použitie pribaleného tomcat serveru. Ten sa spustí pri štarte aplikácie a sprístupní restovú api.
		\end{description}
		
		Súčasťou spring frameworku je webové rozšírenie umožňujúce tvorbu restových služieb. V tejto implementácii som ich rozdelil do štyroch zdrojových súborov podľa oblastí, ktoré obsluhujú. Prvé dva SchemaController a StatementsController poskytujú prístup k správe schém a statementov, ResultController umožňuje prácu s výsledkami statementov a EsperController sa stará o spracovanie prichádzajúcich udalostí. Každá trieda je anotovaná pomocou @RestController a každá metóda definuje unikátnu cestu a HTTP metódu, pomocou ktorej sa vzdialene volá. Za zmienku tiež stojí závislosť ResultController na StatementsController, kde cesta k volaniu jednotlivých metód je vnorená. Výpis \ref{lst:rest-api-path} zobrazuje cesty ku controllerom, pri ktorých si môžeme všimnúť že akceptujú vstup vo forme JSON. V nasledujúcich kapitolách budú tiež detailne špecifikované prístupové cesty k jednotlivým REST metódam. 
		
		\begin{lstlisting}[label=lst:rest-api-path,caption=Definícia ciest REST API]
	@RequestMapping(value = "esper", produces = "application/json")
	@RequestMapping(value = "schemas", produces = "application/json")
	@RequestMapping(value = "statements", produces = "application/json")
	@RequestMapping(value = "/statements/{statement_id}/results", produces = "application/json")
		\end{lstlisting}
		
		Spustenie aplikácie je implementované v triede Application.java, v ktorej je načítaná konfigurácia. Pomocou rozšírenia spring boot sú použité prednastavené (nekonfigurované) hodnoty podľa prístupu convention-over-configuration. Následne je automaticky spustený aplikačný server tomcat, ktorý je súčasťou distribúcie.

	\subsection{Esper engine}
		Esper je v aplikácii implementovaný triedou EsperManager, ktorá poskytuje prístup ku konfiguračným nástrojom a sprístupňuje handler prichádzajúcich udalostí. Pri spustení aplikácie načítava konfiguračné údaje z databázy a inicializuje esper. Najdôležitejšou úlohou tejto triedy je správa schém a statementov.
		\begin{description}
			\item[Schémy] sú reprezentované XML (org.w3c.dom.Node) dokumentom. Oproti POJO reprezentácii umožňuje tento formát vytváranie schém počas behu čo je z pohľadu užívateľa nutnosťou. V prípade potreby by bolo možné použiť udalosti reprezentované pomocou java.util.Map alebo objektovým poľom, avšak to vyžaduje definovanie formátu prenosu a následné spracovanie do požadovaného formátu klientom, čo nie je veľmi intuitívne. Použitie XML reprezentácie klientovi umožní komunikovať priamo s esperom.
			
			\item[Udalosti] ktoré engine spracováva musia byť v XML formáte. Toto obmedzenie je zapríčinené XML reprezentáciou schém. Ako zdroje udalostí týmto eliminujeme adaptéry CSV a HTTP z esperio knižnice. Na prijímanie XML udalostí slúži rest služba. Tá spracováva vstupný stream dvoma spôsobmi:
			\begin{itemize}
				\item Ako jednotlivé udalosti, kde koreňový element udalosti reprezentuje názov schémy reprezentujúcej udalosť.
				\item Ako stream udalostí, kde je koreňový element nazvaný "events" a obaľuje jednotlivé udalosti definované v predošlom bode. Koreňový element je v tomto prípade ignorovaný.
			\end{itemize}
			
			\item[Statementy] pridávané do esper engine môžu obsahovať len meno a epl výraz. Preto je ku každému statementu priradený aj užívateľský objekt - statementBean s dodatočnými informáciami:
			\begin{itemize}
				\item ID ktoré unikátne identifikuje statement v rámci celej aplikácie, nie len daného esper provideru
				\item TTL hovoriaci ako dlho má byť nájdená udalosť perzistentná.
				\item STATE udávajúci či je konkrétny statement spustený alebo zastavený
			\end{itemize}
				

			Pri pridávaní statementu do esper engine je kontrolovaná unikátnosť mena v rámci daného esper providera. V prípade že existuje statement s rovnakým menom je meno doplnené o "--N", kde N značí najbližšie voľné celé číslo. Takto upravený statement je následne uložený.
			
			Pri pridávaní XML schém udalostí je nutné ich konvertovať do typu Document. To zaobstaráva trieda Helpers.java, ktorá sa zároveň stará napríklad o konvertovanie typov udalostí do JSON formátu.
			
		\end{description}
		
		Aplikácia definuje jeden globálny listener, ktorý je priradený všetkým statementom. Ten v prípade výskytu udalosti vyhovujúcej niektorému z definovaných statementov uloží udalosť vo forme obsahu json objektu do databázy.
		
		Esper umožňuje export výsledkov pomocou JSONRenderer a XMLRenderer, avšak tieto triedy produkujú formátovaný výstup, čo je v serverovej časti aplikácie neželané. Preto je konverzia realizovaná upravenými verziami týchto tried, ktoré nepridávajú formátovacie znaky a produkujú validné XML a JSON dokumenty. Predvolene je použitý upravený JSONRenderer.
		
		Pri ukladaní týchto týchto výsledkov do databázy je nastavený TTL, ktorý bol definovaný pri vytvorení statementu. Ak TTL pri vytvorení statementu nebolo definované použije sa predvolené nastavenie, kde sú výsledky persistentné až kým ich užívateľ manuálne neodstráni.

	\subsection{Maven}
		Zostavenie projektu je jednou z nevyhnutných súčastí tvorby java aplikácií. Na uľahčenie tohoto procesu je možné použiť viacero nástrojov, ktorých hlavnými predstaviteľmi sú maven, gradle a ant. Api komponent tejto aplikácie je zostavený pomocou nástroja maven. 
		
		Maven uľahčuje prácu vo viacerých oblastiach, a to \cite{web:maven-doc}:
		\begin{itemize}
			\item Uľahčenie prekladu aplikácie
			\item Poskytnutie jednotného riešenia pre zostavenie aplikácie
			\item Poskytnutie informácií o projekte
			\item Poskytnutie vzorov pre vývoj aplikácií
			\item Umožnenie transparentnej migrácie nových vlastností programu
		\end{itemize}
		Pre túto prácu je najdôležitejšia prvá oblasť. Vďaka mavenu nemusí distribúcia projektu obsahovať všetky knižnice závislostí, ani nemusia byť jednotlivo sťahované pri zostavovaní projektu. Všetky potrebné závislosti sú definované v súbore pom.xml a pri preklade automaticky stiahnuté z internetu. Tento súbor zároveň definuje vlastnosti projektu ako názov, verziu, verziu javy použitú pre zostavenie, spôsob generovania dokumentácie a iné detaily.
		
		Maven tiež umožňuje vytvárať v pom.xml súboroch závislosti a odkazovať sa na externé konfigurácie. Táto funkcionalita je v projekte využitá pri spring závislostiach, kde je verzia niektorých komponent definovaná v externom rodičovskom súbore. Rodičom spring závislostí projektu je spring-boot-starter-parent.
		
		%Väčšina funkcionality mavenu sa skladá z pluginov, k

\section{ThesisWeb}
	Web časť projektu slúži ako administračné rozhranie. Je riešené formou webovej aplikácie, ktorej základ je framework Ruby On Rails. Ten umožňuje rýchle vytváranie stránok, kde prevažuje prístup "convention over configuration". Dôležitou súčasťou frameworku sú gemy, ktoré reprezentujú závislosti projektu. Jedným z najpodstatnejších v tomto projekte je gem "her", ktorý zabezpečuje komunikáciu s Api časťou projektu.
	
	Grafická stránka tohoto projektu sa opiera o framework Bootstrap. Ten v základnej konfigurácii poskytuje html komponenty s vylepšeným UI. Tiež opravuje niektoré chyby kompatibility pri zobrazovaní stránok v rôznych prehliadačoch.
	
	Web nevyužíva žiadne persistentné úložisko dát. Všetky realizované zmeny sú posielané na restovú api, ktorá zmeny spracuje a uloží. Zobrazované údaje sú tiež získavané zo vzdialeného zdroja.
		
	presmerovanie v pripade ze engine je offline
	napojenie cez konfiguraciu v her
	usecase


	
\section{UseCase}
	Na predvedenie možností použitia aplikácie som vytvoril 2 jednoduché programy. Prvý Twitter Stream demonštruje možnosť zasielania udalostí na server a Contacts Web predstavuje možnosť alternatívneho použitia esperu. 
	
	\subsection{Twitter Stream}
	Twitter Stream predstavuje možnosť zasielanie streamu udalostí na REST rozhranie serveru. Skript je napísaný v Ruby a demonštruje ako sa je možné pomocou necelých 30 riadkov kódu napojiť na Twitter Api a presmerovať vzorku tweetov na server. Prijatý tweet je vo forme objektu, ktorý je nutné pred preposlaním formátovať do XML dokumentu. Skript pred spustením odošle na server požiadavku pre registrovanie schémy tweetu, ktorá sa nachádza v samostatnom súbore.
	
	Podobne ako je predvedené v Twitter Stream je možné naprogramovať ďalšie generátory udalostí. Jedinou podmienkou je definovanie schémy (čo je možné aj pomocou administračného rozhrania) pred spustením generátora a streamovanie udalostí vo forme XML dokumentov na URL definovanú v administračnom rozhraní.
	
	\subsection{Contacts Web}
	Contacts Web je webová aplikácia, zostavená pomocou frameworku Sinatra a Bootstrap. Aplikácia obsahuje prezentačnú a aplikačnú vrstvu, databázová vrstva je riešená pomocou REST volaní na server. Vďaka tomu je možné logiku aplikácie zmestiť do necelých 30 riadkov kódu.
	
	Logika aplikácie pozostáva z obsluhy požiadavkov na vytvorenie nového kontaktu, zmazanie existujúceho a výpis existujúcich kontaktov. Všetky tieto požiadavky sú posielané na server.
	
	Možnosť filtrovania údajov pomocou preddefinovaných pravidiel.
	Deklaratívne programovanie.
	